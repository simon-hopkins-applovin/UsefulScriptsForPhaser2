
// -- user code here --

/* --- start generated code --- */

// Generated by  1.5.4 (Phaser v2.6.2)


/**
 * BSBlock.
 * @param {Phaser.Game} aGame A reference to the currently running game.
 * @param {Phaser.Group} aParent The parent Group (or other {@link DisplayObject}) that this group will be added to.    If undefined/unspecified the Group will be added to the {@link Phaser.Game#world Game World}; if null the Group will not be added to any parent.
 * @param {string} aName A name for this group. Not used internally but useful for debugging.
 * @param {boolean} aAddToStage If true this group will be added directly to the Game.Stage instead of Game.World.
 * @param {boolean} aEnableBody If true all Sprites created with {@link #create} or {@link #createMulitple} will have a physics body created on them. Change the body type with {@link #physicsBodyType}.
 * @param {number} aPhysicsBodyType The physics body type to use when physics bodies are automatically added. See {@link #physicsBodyType} for values.
 */
function BSBlock(aGame, aParent, aName, aAddToStage, aEnableBody, aPhysicsBodyType) {
	
	Phaser.Group.call(this, aGame, aParent, aName, aAddToStage, aEnableBody, aPhysicsBodyType);
	var __visualsParent = this.game.add.group(this);
	
	var __baseSprite = this.game.add.sprite(0.0, 0.0, 'Block_Yellow', null, __visualsParent);
	__baseSprite.anchor.set(0.5, 0.5);
	
	var __glowblock = this.game.add.sprite(0.0, 0.0, 'Block_highlight', null, __visualsParent);
	__glowblock.anchor.set(0.5, 0.5);
	
	var __highlight = this.game.add.sprite(0.0, 0.0, 'Block_glow', null, __visualsParent);
	__highlight.anchor.set(0.5, 0.5);
	
	var __yellowHighlight = this.game.add.sprite(0.0, 0.0, 'Nervous_overlay', null, __visualsParent);
	__yellowHighlight.anchor.set(0.5, 0.5);
	
	var __redHighlight = this.game.add.sprite(-3.0, 0.0, 'Block_highlight_red', null, __visualsParent);
	__redHighlight.anchor.set(0.5, 0.5);
	
	var __faceParent = this.game.add.group(__visualsParent);
	__faceParent.scale.set(0.8, 0.8);
	
	var __faceVisual = this.game.add.sprite(0.0, 0.0, 'YELLOW_default', null, __faceParent);
	__faceVisual.anchor.set(0.5, 0.5);
	
	var __pupilParent = this.game.add.group(__faceParent);
	
	var __rightPupil = this.game.add.sprite(-24.0, -1.0, 'YELLOW_Pupil', null, __pupilParent);
	__rightPupil.anchor.set(0.5, 0.5);
	
	var __leftPupil = this.game.add.sprite(17.0, -1.0, 'YELLOW_Pupil', null, __pupilParent);
	__leftPupil.anchor.set(0.5, 0.5);
	
	var __lids = this.game.add.sprite(0.0, 0.0, 'YELLOW_default_lids', null, __faceParent);
	__lids.anchor.set(0.5, 0.5);
	
	
	
	// fields
	
	this.f_visualsParent = __visualsParent;
	this.f_baseSprite = __baseSprite;
	this.f_glowblock = __glowblock;
	this.f_highlight = __highlight;
	this.f_yellowHighlight = __yellowHighlight;
	this.f_redHighlight = __redHighlight;
	this.f_faceParent = __faceParent;
	this.f_faceVisual = __faceVisual;
	this.f_pupilParent = __pupilParent;
	this.f_rightPupil = __rightPupil;
	this.f_leftPupil = __leftPupil;
	this.f_lids = __lids;
	
	this.afterCreate();
	
}

/** @type Phaser.Group */
var BSBlock_proto = Object.create(Phaser.Group.prototype);
BSBlock.prototype = BSBlock_proto;
BSBlock.prototype.constructor = BSBlock;

/* --- end generated code --- */
// -- user code here --


BSBlock.prototype.afterCreate = function(){
	this.baseSprite = this.f_baseSprite;
	this.glowSprite = this.f_glowblock;
	this.highlight = this.f_highlight;
	this.glowSprite.blendMode = PIXI.blendModes.ADD;
	this.highlight.blendMode = PIXI.blendModes.ADD;
	this.highlight.alpha = 0;
	this.glowSprite.alpha = 0;
	this.f_redHighlight.alpha = 0;
	this.f_yellowHighlight.alpha = 0;
	this.f_faceParent.baseScale = this.f_faceParent.scale.clone();
	this.isGlowing = false;
	this.color = null;
	this.isPlacable = true;
	this.f_pupilParent.forEach(function(p){
		p.basePos = p.position.clone();
	}, this);
};

BSBlock.prototype.setColor = function(color){
	this.color = color;
	switch(color){
		case "yellow":
			this.baseSprite.loadTexture("Block_Yellow");

			this.f_lids.loadTexture("YELLOW_default_lids");
			break;
		case "orange":
			this.baseSprite.loadTexture("Block_orange");
			this.f_lids.loadTexture("ORANGE_default_lids");
			
			break;
		case "purple":
			this.baseSprite.loadTexture("Block_purple");
			
			break;
		case "red":
			this.baseSprite.loadTexture("Block_Red");
			this.f_lids.loadTexture("RED_default_lids");
			break;
		case "blue":
			this.baseSprite.loadTexture("Block_blue");
			this.f_lids.loadTexture("BLUE_default_lids");
			break;
	}
	this.f_lids.alpha = 0;
	this.faceSM = new StateMachine("DEFAULT", "WATCHING", "MATCH", "NERVOUS", "DESTROY");
	this.faceSM.states.DEFAULT.SM = new StateMachine("NORMAL", "BLINK");
	this.f_pupilParent.forEach(function(p){
		p.alpha = 1;
		if(this.color == "orange"){
			p.moveBounds = new Phaser.Circle(p.basePos.x, p.basePos.y+5, 15);
		}else if(this.color == "blue"){
			p.moveBounds = new Phaser.Circle(p.basePos.x, p.basePos.y+8, 20);
		}else if(this.color == "red"){
			p.moveBounds = new Phaser.Circle(p.basePos.x, p.basePos.y, 20);
		}else{
			p.moveBounds = new Phaser.Circle(p.basePos.x, p.basePos.y, 25);
		}
		p.targetEyePos = new Phaser.Point(p.moveBounds.x, p.moveBounds.y);
		
	}, this);
	
	var lookTarget = null;
	 
	this.faceSM.states.WATCHING.onEnter.add(function(data){
		switch(color){
			case "yellow":
				this.f_faceVisual.loadTexture("YELLOW_ooo");
				break;
			case "orange":
				break;
			case "purple":
				
				break;
			case "red":
				break;
		}
		lookTarget = data.blockToFollow;
		
		
	}, this);
	this.faceSM.states.WATCHING.onUpdate.add(function(data){
		if(this.color == "purple"){
			return;
		}
		var targetPos = new Phaser.Point(lookTarget.centerX, lookTarget.centerY);
		this.f_pupilParent.forEach(function(p){
			var center = new Phaser.Point(p.moveBounds.x, p.moveBounds.y);
			var localTargetPos = this.game.world.worldTransform.apply(this.f_pupilParent.worldTransform.applyInverse(targetPos));
			var angleTo = Phaser.Point.angle(localTargetPos, center);
			angleTo = Phaser.Math.normalizeAngle(angleTo);
			p.targetEyePos = center.clone().add(Math.cos(angleTo)*p.moveBounds.radius, Math.sin(angleTo)*p.moveBounds.radius);
			if(this.color == "red"){
				if(angleTo>Math.PI && angleTo<Math.PI*2){
					p.targetEyePos.y = Phaser.Math.mapLinear(angleTo, Math.PI, Math.PI*2, -2, -3);
				}else{
					
					
					p.targetEyePos = center.clone().add(Math.cos(angleTo)*p.moveBounds.radius, Math.sin(angleTo)*p.moveBounds.radius/3);
				}
				
			}
			
		}, this);
		
	}, this);
	
	var blinkEvent = null;
	var blink = function(init){
		if(this.color == "purple"){
			return;
		}
		if(!init){
			
			this.f_lids.alpha = 1;
			this.game.time.events.add(200, function(){
				this.f_lids.alpha = 0;
			}, this);
		}
		
		blinkEvent = this.game.time.events.add(this.game.rnd.realInRange(1000, 10000), blink.bind(this, false), this);
	};
	
	this.faceSM.states.DEFAULT.onEnter.add(function(data){
		switch(color){
			case "yellow":
				this.f_faceVisual.loadTexture("YELLOW_default");
				break;
			case "orange":
				this.f_faceVisual.loadTexture("ORANGE_Default");
				break;
			case "purple":
				this.f_faceVisual.loadTexture("PURPLE_default");
				
				break;
			case "red":
				this.f_faceVisual.loadTexture("RED_default");
				break;
			case "blue":
				this.f_faceVisual.loadTexture("BLUE_default");
				break;
		}
		blink.call(this, true);
			
		this.f_pupilParent.forEach(function(p){
			p.targetEyePos = new Phaser.Point(p.moveBounds.x, p.moveBounds.y);
		}, this);
		
		
	}, this);
	this.faceSM.states.DEFAULT.onExit.add(function(data){
		if(blinkEvent){
			this.game.time.events.remove(blinkEvent);
		}
		
	}, this);
	this.faceSM.states.MATCH.onEnter.add(function(data){
		this.f_pupilParent.forEach(function(p){
			p.alpha = 0;
		}, this);
		switch(color){
			case "yellow":
				this.f_faceVisual.loadTexture("YELLOW_match");
				
				break;
			case "orange":
				this.f_faceVisual.loadTexture("ORANGE_match");
				
				break;
			case "purple":
				this.f_faceVisual.loadTexture("PURPLE_match");
				break;
			case "red":
				this.f_faceVisual.loadTexture("RED_match");
				break;
			case "blue":
				this.f_faceVisual.loadTexture("BLUE_Match");
				break;	
			
		}
		
		
	}, this);
	
	var nervousExit = null;
	this.faceSM.states.NERVOUS.onEnter.add(function(data){
		this.f_redHighlight.alphaTween = this.game.add.tween((this.parent instanceof Cell)?this.f_yellowHighlight:this.f_redHighlight).to({alpha: 0.8}, 200, Phaser.Easing.Linear.None, true);
		switch(color){
			case "yellow":
				this.f_faceVisual.loadTexture("YELLOW_nervous");
				break;
			case "orange":
				
				break;
			case "purple":
				break;
			case "red":
				break;
			case "blue":
				break;	
			
		}
		if(data.persistant){
			return;
		}
		nervousExit = this.game.time.events.add(500, function(){
			this.faceSM.changeState("DEFAULT");
		}, this);
		
	}, this);
	
	this.faceSM.states.NERVOUS.onExit.add(function(data){
		if(nervousExit){
			this.game.time.events.remove(nervousExit);
		}
		this.f_redHighlight.alphaTween = this.game.add.tween((this.parent instanceof Cell)?this.f_yellowHighlight:this.f_redHighlight).to({alpha: 0}, 200, Phaser.Easing.Linear.None, true);
		
		
		
	}, this);

	
	
	
	
	this.faceSM.onUpdateSignal.add(function(){
		this.f_pupilParent.forEach(function(p){
			var endPos = Phaser.Point.interpolate(p.position, p.targetEyePos, this.game.time.physicsElapsed*10);
			p.position.setTo(endPos.x, endPos.y);
		}, this);
	}, this);
	
	
	
	this.faceSM.changeState("DEFAULT");
};


BSBlock.prototype.boardDestroyAnim = function(delay, onComplete){
	var scaleTween = this.game.add.tween(this.baseSprite.scale).to({x: 0, y: 0}, 300, Phaser.Easing.Sinusoidal.In, true, delay);
	this.game.add.tween(this.f_faceParent.scale).to({x: 0, y: 0}, 300, Phaser.Easing.Sinusoidal.In, true, delay).onComplete.add(function(){
		this.f_faceParent.scale.setTo(this.f_faceParent.baseScale.x, this.f_faceParent.baseScale.y);

	}, this);
	this.highlight.scale.setTo(0);
	this.highlight.alpha = 1;
	this.game.add.tween(this.highlight.scale).to({x: 1.1, y: 1.1}, 300, Phaser.Easing.Sinusoidal.In, true, delay);
	this.game.add.tween(this.highlight).to({alpha: 0}, 100, Phaser.Easing.Linear.None, true, delay+200);
	scaleTween.onComplete.add(function(){
		this.baseSprite.scale.setTo(1);
		if(onComplete){
			onComplete.call(this);
		}
	}, this);
	
}